// Code generated by entc, DO NOT EDIT.

package handler

import (
	"net/http"
	"strconv"

	"github.com/go-chi/chi"
	"github.com/liip/sheriff"
	"github.com/masseelch/render"

	"github.com/masseelch/go-api-skeleton/ent"
	"github.com/masseelch/go-api-skeleton/ent/account"
	"github.com/masseelch/go-api-skeleton/ent/tag"
	"github.com/masseelch/go-api-skeleton/ent/transaction"
	"github.com/masseelch/go-api-skeleton/ent/user"
)

// This function fetches the Account model identified by a give url-parameter from
// database and returns it to the client.
func (h AccountHandler) Read(w http.ResponseWriter, r *http.Request) {
	idp := chi.URLParam(r, "id")
	if idp == "" {
		h.logger.WithField("id", idp).Info("empty 'id' url param")
		render.BadRequest(w, r, "id cannot be ''")
		return
	}
	id, err := strconv.Atoi(idp)
	if err != nil {
		h.logger.WithField("id", idp).Info("error parsing url parameter 'id'")
		render.BadRequest(w, r, "id must be a positive integer greater zero")
		return
	}

	// todo - nested eager loading?
	e, err := h.client.Account.Query().Where(account.ID(id)).Only(r.Context())
	if err != nil {
		switch err.(type) {
		case *ent.NotFoundError:
			h.logger.WithError(err).WithField("Account.id", id).Debug("job not found")
			render.NotFound(w, r, err)
			return
		case *ent.NotSingularError:
			h.logger.WithError(err).WithField("Account.id", id).Error("duplicate entry for id")
			render.InternalServerError(w, r, nil)
			return
		default:
			h.logger.WithError(err).WithField("Account.id", id).Error("error fetching node from db")
			render.InternalServerError(w, r, nil)
			return
		}
	}

	d, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"account:list"}}, e)
	if err != nil {
		h.logger.WithError(err).WithField("Account.id", id).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("account", e.ID).Info("account rendered")
	render.OK(w, r, d)
}

// This function fetches the Tag model identified by a give url-parameter from
// database and returns it to the client.
func (h TagHandler) Read(w http.ResponseWriter, r *http.Request) {
	idp := chi.URLParam(r, "id")
	if idp == "" {
		h.logger.WithField("id", idp).Info("empty 'id' url param")
		render.BadRequest(w, r, "id cannot be ''")
		return
	}
	id, err := strconv.Atoi(idp)
	if err != nil {
		h.logger.WithField("id", idp).Info("error parsing url parameter 'id'")
		render.BadRequest(w, r, "id must be a positive integer greater zero")
		return
	}

	// todo - nested eager loading?
	e, err := h.client.Tag.Query().Where(tag.ID(id)).Only(r.Context())
	if err != nil {
		switch err.(type) {
		case *ent.NotFoundError:
			h.logger.WithError(err).WithField("Tag.id", id).Debug("job not found")
			render.NotFound(w, r, err)
			return
		case *ent.NotSingularError:
			h.logger.WithError(err).WithField("Tag.id", id).Error("duplicate entry for id")
			render.InternalServerError(w, r, nil)
			return
		default:
			h.logger.WithError(err).WithField("Tag.id", id).Error("error fetching node from db")
			render.InternalServerError(w, r, nil)
			return
		}
	}

	d, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"tag:list"}}, e)
	if err != nil {
		h.logger.WithError(err).WithField("Tag.id", id).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("tag", e.ID).Info("tag rendered")
	render.OK(w, r, d)
}

// This function fetches the Transaction model identified by a give url-parameter from
// database and returns it to the client.
func (h TransactionHandler) Read(w http.ResponseWriter, r *http.Request) {
	idp := chi.URLParam(r, "id")
	if idp == "" {
		h.logger.WithField("id", idp).Info("empty 'id' url param")
		render.BadRequest(w, r, "id cannot be ''")
		return
	}
	id, err := strconv.Atoi(idp)
	if err != nil {
		h.logger.WithField("id", idp).Info("error parsing url parameter 'id'")
		render.BadRequest(w, r, "id must be a positive integer greater zero")
		return
	}

	// todo - nested eager loading?
	e, err := h.client.Transaction.Query().Where(transaction.ID(id)).Only(r.Context())
	if err != nil {
		switch err.(type) {
		case *ent.NotFoundError:
			h.logger.WithError(err).WithField("Transaction.id", id).Debug("job not found")
			render.NotFound(w, r, err)
			return
		case *ent.NotSingularError:
			h.logger.WithError(err).WithField("Transaction.id", id).Error("duplicate entry for id")
			render.InternalServerError(w, r, nil)
			return
		default:
			h.logger.WithError(err).WithField("Transaction.id", id).Error("error fetching node from db")
			render.InternalServerError(w, r, nil)
			return
		}
	}

	d, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"transaction:list"}}, e)
	if err != nil {
		h.logger.WithError(err).WithField("Transaction.id", id).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("transaction", e.ID).Info("transaction rendered")
	render.OK(w, r, d)
}

// This function fetches the User model identified by a give url-parameter from
// database and returns it to the client.
func (h UserHandler) Read(w http.ResponseWriter, r *http.Request) {
	idp := chi.URLParam(r, "id")
	if idp == "" {
		h.logger.WithField("id", idp).Info("empty 'id' url param")
		render.BadRequest(w, r, "id cannot be ''")
		return
	}
	id, err := strconv.Atoi(idp)
	if err != nil {
		h.logger.WithField("id", idp).Info("error parsing url parameter 'id'")
		render.BadRequest(w, r, "id must be a positive integer greater zero")
		return
	}

	// todo - nested eager loading?
	e, err := h.client.User.Query().Where(user.ID(id)).Only(r.Context())
	if err != nil {
		switch err.(type) {
		case *ent.NotFoundError:
			h.logger.WithError(err).WithField("User.id", id).Debug("job not found")
			render.NotFound(w, r, err)
			return
		case *ent.NotSingularError:
			h.logger.WithError(err).WithField("User.id", id).Error("duplicate entry for id")
			render.InternalServerError(w, r, nil)
			return
		default:
			h.logger.WithError(err).WithField("User.id", id).Error("error fetching node from db")
			render.InternalServerError(w, r, nil)
			return
		}
	}

	d, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"user:list"}}, e)
	if err != nil {
		h.logger.WithError(err).WithField("User.id", id).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("user", e.ID).Info("user rendered")
	render.OK(w, r, d)
}
