// Code generated by entc, DO NOT EDIT.

package handler

import (
	"encoding/json"
	"net/http"
	"time"

	"github.com/go-playground/validator/v10"
	"github.com/liip/sheriff"
	"github.com/masseelch/render"
)

// struct to bind the post body to.
type jobCreateRequest struct {
	Date                   time.Time `json:"date,omitempty" groups:"job:list,job:read"`
	Task                   string    `json:"task,omitempty" groups:"job:list,job:read" validate:"required"`
	State                  string    `json:"state,omitempty" groups:"job:list,job:read" validate:"required,oneof=open closed billed"`
	Report                 string    `json:"report,omitempty" groups:"job:list,job:read"`
	Rest                   string    `json:"rest,omitempty" groups:"job:list,job:read"`
	Note                   string    `json:"note,omitempty" groups:"job:list,job:read"`
	CustomerName           string    `json:"customerName,omitempty" groups:"job:list,job:read"`
	RiskAssessmentRequired bool      `json:"riskAssessmentRequired,omitempty" groups:"job:list,job:read"`
	MaintenanceRequired    bool      `json:"maintenanceRequired,omitempty" groups:"job:list,job:read"`

	Users []int `users,omitempty`
}

// This function creates a new Job model and stores it in the database.
func (h JobHandler) Create(w http.ResponseWriter, r *http.Request) {
	// Get the post data.
	d := jobCreateRequest{} // todo - allow form-url-encdoded/xml/protobuf data.
	if err := json.NewDecoder(r.Body).Decode(&d); err != nil {
		h.logger.WithError(err).Error("error decoding json")
		render.BadRequest(w, r, "invalid json string")
		return
	}

	// Validate the data.
	if err := h.validator.Struct(d); err != nil {
		if err, ok := err.(*validator.InvalidValidationError); ok {
			h.logger.WithError(err).Error("error validating request data")
			render.InternalServerError(w, r, nil)
			return
		}

		h.logger.WithError(err).Info("validation failed")
		render.BadRequest(w, r, err)
		return
	}

	// Save the data.
	b := h.client.Job.Create().
		SetDate(d.Date).
		SetTask(d.Task).
		SetState(d.State).
		SetReport(d.Report).
		SetRest(d.Rest).
		SetNote(d.Note).
		SetCustomerName(d.CustomerName).
		SetRiskAssessmentRequired(d.RiskAssessmentRequired).
		SetMaintenanceRequired(d.MaintenanceRequired).
		AddUserIDs(d.Users...)

	// Store in database.
	e, err := b.Save(r.Context())
	if err != nil {
		h.logger.WithError(err).Error("error saving Job")
		render.InternalServerError(w, r, nil)
		return
	}

	// Serialize the data.
	j, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"job:read", "user:list"}}, e)
	if err != nil {
		h.logger.WithError(err).WithField("Job.id", e.ID).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("job", e.ID).Info("job rendered")
	render.OK(w, r, j)
}

// struct to bind the post body to.
type sessionCreateRequest struct {
	IdleTimeExpiredAt time.Time `json:"idleTimeExpiredAt,omitempty"`
	LifeTimeExpiredAt time.Time `json:"lifeTimeExpiredAt,omitempty"`
}

// This function creates a new Session model and stores it in the database.
func (h SessionHandler) Create(w http.ResponseWriter, r *http.Request) {
	// Get the post data.
	d := sessionCreateRequest{} // todo - allow form-url-encdoded/xml/protobuf data.
	if err := json.NewDecoder(r.Body).Decode(&d); err != nil {
		h.logger.WithError(err).Error("error decoding json")
		render.BadRequest(w, r, "invalid json string")
		return
	}

	// Validate the data.
	if err := h.validator.Struct(d); err != nil {
		if err, ok := err.(*validator.InvalidValidationError); ok {
			h.logger.WithError(err).Error("error validating request data")
			render.InternalServerError(w, r, nil)
			return
		}

		h.logger.WithError(err).Info("validation failed")
		render.BadRequest(w, r, err)
		return
	}

	// Save the data.
	b := h.client.Session.Create().
		SetIdleTimeExpiredAt(d.IdleTimeExpiredAt).
		SetLifeTimeExpiredAt(d.LifeTimeExpiredAt)

	// Store in database.
	e, err := b.Save(r.Context())
	if err != nil {
		h.logger.WithError(err).Error("error saving Session")
		render.InternalServerError(w, r, nil)
		return
	}

	// Serialize the data.
	j, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"session:read"}}, e)
	if err != nil {
		h.logger.WithError(err).WithField("Session.id", e.ID).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("session", e.ID).Info("session rendered")
	render.OK(w, r, j)
}

// struct to bind the post body to.
type userCreateRequest struct {
	Email    string `json:"email,omitempty" groups:"user:list"`
	Password string `json:"password,omitempty"`
	Enabled  bool   `json:"enabled,omitempty" groups:"user:list"`

	Jobs []int `jobs,omitempty`
}

// This function creates a new User model and stores it in the database.
func (h UserHandler) Create(w http.ResponseWriter, r *http.Request) {
	// Get the post data.
	d := userCreateRequest{} // todo - allow form-url-encdoded/xml/protobuf data.
	if err := json.NewDecoder(r.Body).Decode(&d); err != nil {
		h.logger.WithError(err).Error("error decoding json")
		render.BadRequest(w, r, "invalid json string")
		return
	}

	// Validate the data.
	if err := h.validator.Struct(d); err != nil {
		if err, ok := err.(*validator.InvalidValidationError); ok {
			h.logger.WithError(err).Error("error validating request data")
			render.InternalServerError(w, r, nil)
			return
		}

		h.logger.WithError(err).Info("validation failed")
		render.BadRequest(w, r, err)
		return
	}

	// Save the data.
	b := h.client.User.Create().
		SetEmail(d.Email).
		SetPassword(d.Password).
		SetEnabled(d.Enabled).
		AddJobIDs(d.Jobs...)

	// Store in database.
	e, err := b.Save(r.Context())
	if err != nil {
		h.logger.WithError(err).Error("error saving User")
		render.InternalServerError(w, r, nil)
		return
	}

	// Serialize the data.
	j, err := sheriff.Marshal(&sheriff.Options{Groups: []string{"user:read"}}, e)
	if err != nil {
		h.logger.WithError(err).WithField("User.id", e.ID).Error("serialization error")
		render.InternalServerError(w, r, nil)
		return
	}

	h.logger.WithField("user", e.ID).Info("user rendered")
	render.OK(w, r, j)
}
